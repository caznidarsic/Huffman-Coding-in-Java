/* Christian Znidarsic
 * Lab 3
 * EN.605.202.86.SP22 Data Structures
 * 
 * The HuffmanTree class.
 * 
 * 	A lot happens in the HuffmanTree class. This class contains the fields root, codes and preorderTraversal. The
 * root is the root node of the HuffmanTree created with getHuffTree. codes is the hashmap that stores the key-value pairs
 * of letter and code. preorderTraversal is a String that stores the preorder traversal generated by the recursive function
 * preorder().
 * 	
 * 	Broadly speaking, the HuffmanTree class is used to create a Huffman tree, and encode/decode user inputs using
 * the tree it created. */

import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.lang.*;
import java.util.HashMap;

public class HuffmanTree {
	TreeNode root;
	HashMap<Character, String> codes;
	String preorderTraversal = "";
	
	
	
	/* The encode() method takes as input a queue containing a valid clear text file entered by the user, as well
	 * as a PrintWriter object which it uses to write to an output text file. */
	public void encode(Queue input, PrintWriter output) throws IOException {
		//inString is used to store and print the original, non-encoded input text.
		String inString = "";
		//outString is used to store and print the encoded text.
		String outString = "";
		
		
		output.println("The tree traversal is: \n");
		
		//calculate the preorder traversal of the Huffman tree called "root".
		preorder(root);
		output.println(preorderTraversal);
		
		
		output.println("\n\nThe following codes were used: \n");
		
		//print out the characters and their codes to the output .txt file.
		for (char key: codes.keySet()) {
			output.println(key + " = " + codes.get(key));
		}
		
		
		
		output.println("\n\n\nEncoded Clear Text: ");
		output.println("__________________________________________________________________________________________________________________________________________________\n\n");
		
		//this loop iterates through all characters in the input queue and encodes them. 
		while(!input.isEmpty()) {
			
			//get the key from the top item in the queue
			char character = input.front.key;
			//pop the top item from the queue.
			input.dequeue();
			
			//concatenate the current character to inString. 
			inString += Character.toString(character);
			
			//if the character is a letter, then add the corresponding letter code to the outString
			if (Character.isLetter(character)) {
				outString += codes.get(Character.toUpperCase(character));
			}
			/*if the character is a newline, add it to outString and print both the original text, and the encoded
			 * text to the output file.
			 */
			else if (character == '\n') {
				outString += Character.toString(character);
				outString += "\n";
				
				output.println(inString);
				output.println(outString + "\n");
				
				//reset both strings
				inString = "";
				outString = "";
			}
			
		}
		
		output.close();
		
	}
	
	
	
	
	public void decode(Queue input, PrintWriter output) throws IOException {
		//inString is used to store and print the original, non-encoded input text.
		String inString = "";
		//outString is used to store and print the encoded text.
		String outString = "";
		TreeNode curNode = root;
		
		output.println("The tree traversal is: \n");
		
		//calculate the preorder traversal of the Huffman tree called "root".
		preorder(root);
		//print preorder traversal
		output.println(preorderTraversal);
		
		
		output.println("\n\nThe following codes were used: \n");
		
		//print the Huffman codes
		for (char key: codes.keySet()) {
			output.println(key + " = " + codes.get(key));
		}
		
		
		output.println("\n\n\nDecoded Text: ");
		output.println("__________________________________________________________________________________________________________________________________________________\n\n");
		
		
		//this loop iterates through all characters in the input queue and decodes them. 
		while(!input.isEmpty()) {
			
			char character = input.front.key;
			input.dequeue();
			
			inString += Character.toString(character);
			
			//if the character is equal to 0, then traverse left in the Huffman tree.
			if (character == '0') {
				curNode = curNode.left;
				
				//if the node is a leaf, then add the node's key (letter) to outString
				if (isLeaf(curNode)) {
					outString += curNode.key[0];
					//reset curNode to the root of the Huffman tree to start searching for the next char.
					curNode = root;
				}
			}
			//if the character is equal to 1, then traverse left in the Huffman tree.
			else if (character == '1') {
				curNode = curNode.right;
				
				//if the node is a leaf, then add the node's key (letter) to outString
				if (isLeaf(curNode)) {
					outString += curNode.key[0];
					curNode = root;
				}
			}
			/*if the character is a newline, add it to outString and print both the original text, and the encoded
			 * text to the output file.
			 */
			else if (character == '\n') {
				outString += Character.toString(character);
				
				output.println(inString);
				output.println(outString + "\n");
				
				//reset both strings
				inString = "";
				outString = "";
			}
		}
		
		output.close();
		
	}
	

	
	/*
	 * getHuffTree takes a queue containing a valid frequency table as input, and uses it to 
	 * set root equal to the resulting Huffman tree.
	 */
	public void getHuffTree(Queue input) throws IOException, NumberFormatException{
		char letter = ' ';
		String frequency = "";
		int freqInt;
//		int c = 0;
		MinHeap heap = new MinHeap();
		
		/*Read through all chars in the input queue and create nodes based on the frequency 
		table. Push the nodes one by one into the heap. */
		while (!input.isEmpty()) {
			
			char character = input.front.key;
			input.dequeue();
			
			//if the character is a letter, store it in letter
			if (Character.isLetter(character)) {
				letter = character;
			}
			/*if the character is a digit, then it is assumed to be a digit in the frequency in
			the frequency table. Add it to the frequency String. */
			else if (Character.isDigit(character)) {
				frequency = frequency + Character.toString(character);
			}
			/*if the char is a newline, then create a new node with the letter and frequency 
			that were found earlier in the loop. */
			else if (character == '\n') {
				freqInt = Integer.parseInt(frequency);
				TreeNode node = new TreeNode(letter, freqInt);
				//insert the node into the heap.
				heap.insertNode(node);

				//reset the frequency String
				frequency = "";
			}
			
		}
		
		//define 2 TreeNodes
		TreeNode node1;
		TreeNode node2;
		
		/*Pop 2 nodes from the heap, combine them, then reinsert them into the heap.
		The condition to stop is when there is only one node left in the heap. This node
		is the resulting Huffman tree. */ 
		while (!heap.hasOneNode()) {
			//pop 2 nodes
			node1 = heap.removeRoot();
			node2 = heap.removeRoot();
			
			//create new node to combine the two popped nodes
			TreeNode superNode = new TreeNode();
			
			/*compare the priority of the two nodes. Whichever node has priority becomes 
			the left child of the supernode. */
			if (hasPriority(node1, node2)) {
				node1Left(superNode, node1, node2, heap);
			}
			else {
				node2Left(superNode, node1, node2, heap);
			}
				
		}	
		
		//the last node in the heap is the resulting Huffman tree. Store it in the root field.
		root = heap.removeRoot();
		
	}
	
	
	/*
	 * The hasPriority method takes two nodes as input, and determines which has priority.
	 * Returns true if node1 has priority, false if node2 has priority.
	 */
	private boolean hasPriority(TreeNode node1, TreeNode node2) {
		
		int node1Freq = node1.frequency;
		int node2Freq = node2.frequency;

		//first test if one of the nodes has a greater frequency. Node with smaller frequency has priority.
		if (node1Freq < node2Freq) {
			return true;
		}
		else if (node2Freq < node1Freq) {
			return false;
		}
		
		/*if priorities are equal, first tiebreaker is if one node is complex and other is not. In that case,
		the node that is not complex has priority. */
		else if (node1Freq == node2Freq) {
			/*if both are simple or both are complex, last tiebreaker is alphabetical. Lower alphabetically
			has priority. */
			if ((isComplex(node1) && isComplex(node2)) || (!isComplex(node1) && !isComplex(node2))) {
				if (node1.key[0] < node2.key[0]) {
					return true;
				}
				else if (node2.key[0] < node1.key[0]) {
					return false;
				}
			}
			//if node1 is not complex, node2 must be complex, and node1 has priority.
			else if (!isComplex(node1)) {
				return true;
			}
		}
		//else, node2 has priority, meaning we return false.
		return false;
	}
	
	//method to determine if a node is complex.
	private boolean isComplex(TreeNode node) {
		if (node.charArrayLen > 1) {
			return true;
		}
		return false;
	}
	
	
	//method to set node1 to left child of supernode, and node2 to right child of supernode.
	private void node1Left(TreeNode superNode, TreeNode node1, TreeNode node2, MinHeap heap) {
		superNode.left = node1;
		superNode.right = node2;
		superNode.frequency = node1.frequency + node2.frequency;
		superNode.combineKeys(node1, node2);
		
		heap.insertNode(superNode);
	}
	
	
	//method to set node2 to left child of supernode, and node1 to right child of supernode.
	private void node2Left(TreeNode superNode, TreeNode node1, TreeNode node2, MinHeap heap) {
		superNode.left = node2;
		superNode.right = node1;
		superNode.frequency = node1.frequency + node2.frequency;
		superNode.combineKeys(node1, node2);
		
		heap.insertNode(superNode);
	}
		
	
	
	/*getCodes takes a Huffman Tree as input, and uses it to set the codes field to the resulting 
	hashMap containing letters and their corresponding Huffman codes. */
	public void getCodes(TreeNode root, String prefix, HashMap<Character, String> output) {
		
		if (isLeaf(root)) {
			output.put(root.key[0], prefix); 
		}
		else {
			getCodes(root.left, prefix + "0", output);
			getCodes(root.right, prefix + "1", output);
		}
		codes = output;
			
	}
	
	
	//determines if a node is a leaf.
	private boolean isLeaf(TreeNode node) {
		if (node.left == null && node.right == null) {
			return true;
		}
		else {
			return false;
		}
	}
	
	
	//returns the root field of this HuffmanTree object.
	public TreeNode getRoot() {
		return root;
	}
	
	
	/*
	 * Recursive function to traverse the HuffmanTree and set the preorderTraversal field
	 * equal to the resulting String. 
	 */
	public void preorder(TreeNode root) {
		
		if (root != null) {
			for (int i = 0; i < root.charArrayLen; i++) {
				preorderTraversal += Character.toString(root.key[i]);
			}
			preorderTraversal += ": " + root.frequency + ", ";
			
			preorder(root.left);
			preorder(root.right);
		}
		
	}
	
	
}
